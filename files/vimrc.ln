" NeoBundle
"" Basic setup
set rtp+=~/.vim/bundle/neobundle.vim
call neobundle#begin(expand('~/.vim/bundle/'))

"" Appearance
NeoBundle 'morhetz/gruvbox'
NeoBundle 'bling/vim-airline'
NeoBundle 'airblade/vim-gitgutter'
NeoBundle 'Yggdroot/indentLine'

"" Editing
NeoBundle 'raimondi/delimitmate'
NeoBundle 'junegunn/vim-easy-align'
NeoBundle 'sirver/ultisnips',
NeoBundle 'honza/vim-snippets'
NeoBundle 'mattn/emmet-vim'
NeoBundle 'tomtom/tcomment_vim'
NeoBundle 'elixir-lang/vim-elixir'

"" Integration
NeoBundle 'tpope/vim-fugitive'
NeoBundle 'Shougo/unite.vim'
NeoBundle 'scrooloose/syntastic'
NeoBundle 'xolox/vim-easytags'
NeoBundle 'xolox/vim-misc'

"" Support
NeoBundle 'Shougo/vimproc.vim', {'build':{'mac':'make -f make_mac.mak'}}
call     neobundle#end()
filetype plugin indent on
NeoBundleCheck


" Leader settings
let mapleader="\<Space>"
nnoremap <SPACE> <Nop>
set timeoutlen=500


" Appearence
syntax enable
se cursorline

"" Color scheme
set t_Co=256
set background=dark
colorscheme gruvbox
let g:gruvbox_contrast_light="hard"


" Airline
set laststatus=2                                      " to show the airline
set noshowmode                                        " hide vim mode indidicator
let g:airline_extensions=['branch', 'tabline']
let g:airline_powerline_fonts=1
let g:airline#extensions#tabline#enabled=1            " show buffers
let g:airline#extensions#tabline#fnamemod=':t'        " only buff names
let g:airline#extensions#tabline#fnamecollapse=1      " show new buffers on edit

"" Show Vim modes as one letter abbreviations (e.g. NORMAL - N)
let g:airline_mode_map = {
      \ '__' : '-',
      \ 'n'  : 'N',
      \ 'i'  : 'I',
      \ 'R'  : 'R',
      \ 'c'  : 'C',
      \ 'v'  : 'V',
      \ 'V'  : 'V',
      \ '' : 'V',
      \ 's'  : 'S',
      \ 'S'  : 'S',
      \ '' : 'S',
      \ }

"" Hide encoding and format values from the statusline
let g:airline_section_y=''


" Editing
augroup OnBiffeWrite
  autocmd bufwritepre * :%s/\s\+$//e     " autoremove trailing whitespaces
  autocmd bufwritepre * :retab           " convert tabs<->spaces
augroup END

set wildignorecase
set nowrap
set number                               " show line numbers
set colorcolumn=81                       " draw a vertical line
set expandtab tabstop=2                  " expand tabs to 2 spaces
set hidden                               " create buffers without saving changes
set shiftwidth=2

syntax   on
filetype plugin on                       " load ft's plugin if exists
set      dir=/var/tmp,/tmp,.             " alter default dir for swap files

set backspace=2

set encoding=utf-8 fileencoding=utf-8 termencoding=utf-8       " encoding
set nobackup nowritebackup noswapfile autoread                 " no swap
set clipboard=unnamed,unnamedplus
set nofoldenable

nmap L :bnext<cr>
nmap H :bprevious<cr>
imap jj <esc>

nmap <Leader>e ddkP
nmap <Leader>c ddp

vmap <Leader>e xkP`[V`]
vmap <Leader>c xp`[V`]

"" use an undo file
set undofile
set undodir=/Users/aandrieiev/.vimundo/

"" Easier window navigation
nmap <C-h> <C-w>h
nmap <C-j> <C-w>j
nmap <C-k> <C-w>k
nmap <C-l> <C-w>l

set showmatch

"" Close buffer
nmap <leader>d :bp<bar>sp<bar>bn<bar>bd<CR>

"" Nicer non-printed characters
set listchars=tab:⇥\ ,eol:↩


" UltiSnips
let g:UltiSnipsExpandTrigger="<tab>"
let g:UltiSnipsJumpForwardTrigger="<c-b>"
let g:UltiSnipsJumpBackwardTrigger="<c-z>"

" Syntastic
set statusline+=%#warningmsg#
set statusline+=%{SyntasticStatuslineFlag()}
set statusline+=%*

let g:syntastic_always_populate_loc_list = 1
let g:syntastic_check_on_open = 1
let g:syntastic_check_on_wq = 0
let g:syntastic_enable_highlighting = 0
let g:syntastic_error_symbol = "✗"
let g:syntastic_warning_symbol = "⚠"
let g:syntastic_loc_list_height=5

let g:syntastic_mode_map = {
        \ "mode": "active",
        \ "active_filetypes": ["ruby", "eruby", "html", "javascript"],
        \ "passive_filetypes": ["puppet"] }


" EasyAlign
"" Start interactive EasyAlign in visual mode (e.g. vip<Enter>)
vmap <Enter> <Plug>(EasyAlign)

"" Start interactive EasyAlign for a motion/text object (e.g. gaip)
nmap ga <Plug>(EasyAlign)

"" Define custom rules
let g:easy_align_delimiters = {
\ '>': { 'pattern': '>>\|=>\|->\|>' },
\ '/': {
\     'pattern':         '//\+\|/\*\|\*/',
\     'delimiter_align': 'l',
\     'ignore_groups':   ['!Comment'] },
\ }


" Search
set ignorecase smartcase incsearch


" Unite
call unite#filters#matcher_default#use(['matcher_fuzzy'])
call unite#filters#sorter_default#use(['sorter_rank'])

let g:unite_enable_short_source_names=1
let g:unite_source_rec_max_cache_files=0

let g:unite_source_rec_async_command='ag --nocolor --nogroup --hidden -g ""'
let g:unite_source_grep_command = 'ag'
let g:unite_source_grep_default_opts = '--nocolor --nogroup --column'
let unite_ignore_pattern='app\/assets\/images\|_build\|.git\|tmp\|.tmp\|.bower-cache\|vendor'

call unite#custom#source('file_rec,file_rec/async', 'ignore_pattern', unite_ignore_pattern)

call unite#custom#profile('default', 'context', {
\   'winheight': 15,
\   'no-auto-resize': 1,
\   'direction': 'botright',
\   'prompt':  '↳ ',
\   'prompt_direction': 'top',
\ })

nnoremap <leader>f :<C-u>Unite -start-insert buffer bookmark file_rec/async:!<CR>
nnoremap <leader>b :<C-u>Unite -start-insert bookmark:*<CR>
nnoremap <leader>st :<C-u>Unite grep:.<CR>
nnoremap <leader>t :<C-u>Unite grep:.::<C-R><C-w><CR>
nnoremap <Leader>g :<C-u>Unite -buffer-name=search -start-insert line<cr>
" under-cursor word in the dir
" noremap <silent> <Leader>s :Unite grep:.::<C-R><C-w><CR>
" cur buff
" noremap <silent> <Leader>sf :Unite grep:%::<C-r><C-w><CR>
" opened buffs
" noremap <silent> <Leader>sa :Unite grep:$buffers::<C-r><C-w><CR>

function! s:UniteSettings()
  let b:actually_quit=0
  setlocal updatetime=3
  au InsertEnter <buffer> let b:actually_quit=0
  au InsertLeave <buffer> let b:actually_quit=1
  au CursorHold  <buffer> if exists('b:actually_quit') && b:actually_quit | close | endif
endfunction

" au FileType unite call s:UniteSettings()


" Emmet
"" HTML, CSS files only
let g:user_emmet_install_global = 0
autocmd FileType html,css,eruby EmmetInstall


" IndentLine
nmap <Leader>il :IndentLinesToggle<CR>
let g:indentLine_char = "|"
let g:indentLine_enabled = 0

" Tmux integration
if $TMUX != ''
  fun! TmuxMove(direction)
    " Check if we are currently focusing at an edge window.
    " To achieve that,  move to/from the requested window and
    " see if the window number changed
    let oldw = winnr()
    silent! exe 'wincmd ' . a:direction
    let neww = winnr()
    silent! exe oldw . 'wincmd'
    if oldw == neww
      " The focused window is at an edge, so ask tmux to switch panes
      if a:direction == 'j'
        call system("tmux select-pane -D")
      elseif a:direction == 'k'
        call system("tmux select-pane -U")
      elseif a:direction == 'h'
        call system("tmux select-pane -L")
      elseif a:direction == 'l'
        call system("tmux select-pane -R")
      endif
    else
      exe 'wincmd ' . a:direction
    end
  endfun
endif

nnoremap <silent> <c-w>j :silent call TmuxMove('j')<cr>
nnoremap <silent> <c-w>k :silent call TmuxMove('k')<cr>
nnoremap <silent> <c-w>h :silent call TmuxMove('h')<cr>
nnoremap <silent> <c-w>l :silent call TmuxMove('l')<cr>


" Version Control
"" Fugitive
nnoremap <space>gs :Gstatus<CR>

"" Git-gutter
let g:gitgutter_sign_column_always=1
hi clear SignColumn
hi GitGutterAdd ctermbg=bg
hi GitGutterChange ctermbg=bg
hi GitGutterDelete ctermbg=bg
hi GitGutterChangeDelete ctermbg=bg


" Misc
"" Reload vimrc
map <f6> :w<bar>:source ~/.vimrc<cr>:echo "config reloaded!"<cr>

"" Auto-correct typos
if has("user_commands")
  command! -bang -nargs=? -complete=file E e<bang> <args>
  command! -bang -nargs=? -complete=file W w<bang> <args>
  command! -bang -nargs=? -complete=file Wq wq<bang> <args>
  command! -bang -nargs=? -complete=file WQ wq<bang> <args>
  command! -bang Wa wa<bang>
  command! -bang WA wa<bang>
  command! -bang Q q<bang>
  command! -bang QA qa<bang>
  command! -bang Qa qa<bang>
  map q: :q
endif

"" Mappings
nmap <Leader>w :w<CR>
nmap <Leader>q :q<CR>

"" Save as sudo
cmap w!! w !sudo tee > /dev/null %

"" Create the directories missing from path when saving a file
if !exists("*MkNonExDir")
  function MkNonExDir(file, buf)
    if empty(getbufvar(a:buf, '&buftype')) && a:file!~#'\v^\w+\:\/'
      let dir=fnamemodify(a:file, ':h')
      if !isdirectory(dir)
        call mkdir(dir, 'p')
      endif
    endif
  endfunction
endif

augroup BWCCreateDir
  autocmd!
  autocmd BufWritePre * :call MkNonExDir(expand('<afile>'), +expand('<abuf>'))
augroup END
